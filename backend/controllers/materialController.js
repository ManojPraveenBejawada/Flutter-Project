// backend/controllers/materialController.js
const db = require('../db');
const fs = require('fs'); // Node.js File System module for deleting files
const path = require('path'); // Node.js Path module

// Handles saving material info to DB after successful upload by Multer middleware
exports.uploadMaterial = async (req, res) => {
    // Multer adds 'file' and 'body' objects to the request object 'req'
    const { course_id } = req.body;
    const filePath = req.file.filename; // The unique filename generated by Multer
    const originalName = req.file.originalname; // The original name of the file

    // Basic validation
    if (!course_id || !filePath || !originalName) {
        // If somehow Multer succeeded but data is missing, send error
         // Clean up uploaded file if DB insert fails later? Consider this for robustness.
        return res.status(400).json({ message: 'Missing required fields for material upload.' });
    }

    try {
        const [result] = await db.query(
            'INSERT INTO training_materials (course_id, file_path, original_name) VALUES (?, ?, ?)',
            [course_id, filePath, originalName]
        );
        res.status(201).json({ message: 'Material uploaded successfully', materialId: result.insertId });
    } catch (error) {
         console.error("Database error during material upload:", error);
         // Attempt to delete the orphaned file if DB insert failed
         const fullPath = path.join(__dirname, '..', 'uploads', filePath);
         fs.unlink(fullPath, (unlinkErr) => {
            if (unlinkErr) console.error("Error deleting orphaned file:", unlinkErr);
         });
        res.status(500).json({ message: 'Database error saving material info', error });
    }
};

// Fetches all materials associated with a given course ID
exports.getMaterialsForCourse = async (req, res) => {
    const { courseId } = req.params;
    try {
        const [materials] = await db.query(
            'SELECT * FROM training_materials WHERE course_id = ? ORDER BY created_at DESC',
            [courseId]
        );
        res.json(materials);
    } catch (error) {
        console.error("Error fetching materials:", error);
        res.status(500).json({ message: 'Error fetching materials', error });
    }
};

// Deletes a material record from the DB and the corresponding file from the server
exports.deleteMaterial = async (req, res) => {
    const { materialId } = req.params;
    let filePathToDelete = ''; // Store the file path before deleting the DB record

    const connection = await db.getConnection(); // Use transaction for safety

    try {
        await connection.beginTransaction();

        // First, get the file path from the database
        const [materials] = await connection.query('SELECT file_path FROM training_materials WHERE id = ?', [materialId]);
        if (materials.length === 0) {
            await connection.rollback(); // Rollback if material not found
            return res.status(404).json({ message: 'Material not found' });
        }
        filePathToDelete = materials[0].file_path;

        // Delete the database record (associated quizzes/attempts might cascade delete based on DB setup)
        await connection.query('DELETE FROM training_materials WHERE id = ?', [materialId]);

        // If DB deletion is successful, commit the transaction
        await connection.commit();

        // Now, delete the actual file from the 'uploads' folder
        const fullPath = path.join(__dirname, '..', 'uploads', filePathToDelete);
        fs.unlink(fullPath, (err) => {
            if (err) {
                // Log error but still send success as DB record is deleted
                console.error('Error deleting file from filesystem:', err);
                // Decide if this file deletion failure should cause a 500 error or just a warning
                 res.status(200).json({ message: 'Material deleted from DB, but file deletion failed. Please check server logs.' });
            } else {
                res.status(200).json({ message: 'Material deleted successfully' });
            }
        });

    } catch (error) {
        await connection.rollback(); // Rollback on any database error
        console.error("Error deleting material:", error);
        res.status(500).json({ message: 'Error deleting material', error });
    } finally {
        connection.release(); // Always release the connection
    }
};